- finally中代码一定会执行吗？#card#Java
	- 通常情况下，finally的代码一定会被执行，但是这是有前提的：
		- 1、对应 try 语句块被执行，
		- 2、程序正常运行。
	- 发生以下情况，都会导致finally不会执行
		- 1、System.exit()方法被执行
		- 2、Runtime.getRuntime().halt()方法被执行
		- 3、try或者catch中有死循环
		- 4、操作系统强制杀掉了JVM进程，如执行了kill -9
		- 5、其他原因导致的虚拟机崩溃了
		- 6、虚拟机所运行的环境挂了，如计算机电源断了
- Java中的枚举有什么特点和好处#card#Java
	- 枚举的valueOf可以自动对入参进行非法参数的校验
	- 可以调用枚举中的方法，相对于普通的常量来说操作性更强
	- 枚举实现接口的话，可以很容易的实现策略模式
	- 枚举可以自带属性，扩展性更强
- 什么是AIO、BIO和NIO#card#Java
	- BIO （Blocking I/O）：同步阻塞I/O，是JDK1.4之前的传统IO模型。 线程发起IO请求后，一直阻塞，直到缓冲区数据就绪后，再进入下一步操作。
	- NIO （Non-Blocking I/O）：同步非阻塞IO，线程发起IO请求后，不需要阻塞，立即返回。用户线程不原地等待IO缓冲区，可以先做一些其他操作，只需要定时轮询检查IO缓冲区数据是否就绪即可。
	- AIO （ Asynchronous I/O）：异步非阻塞I/O模型。线程发起IO请求后，不需要阻塞，立即返回，也不需要定时轮询检查结果，异步IO操作之后会回调通知调用方。
- Java是值传递还是引用传递#card#Java
	- 值传递
- JDK新版本中都有哪些新特性#card#Java
	- JDK 8中推出了Lambda表达式、Stream、Optional、新的日期API等
	- JDK 9中推出了模块化
	- JDK 10中推出了本地变量类型推断
	- JDK 12中增加了switch表达式
	- JDK 13中增加了text block
	- JDK 14中增加了Records
	- JDK 14中增加了instance模式匹配
	- JDK 15中增加了封闭类
	- JDK 17中扩展了switch模式匹配
	- JDK 21中增加了协程
- String是如何实现不可变的#card#Java
	- String类被声明为final，这意味着它不能被继承。那么他里面的方法就是没办法被覆盖的。
	- 用final修饰字符串内容的char[]（从JDK 1.9开始，char[]变成了byte[]），由于该数组被声明为final，一旦数组被初始化，就不能再指向其他数组。
	- String类没有提供用于修改字符串内容的公共方法。例如，没有提供用于追加、删除或修改字符的方法。如果需要对字符串进行修改，会创建一个新的String对象。
- 什么是序列化与反序列化#card#Java
	- 序列化就是把Java对象序列化成字节数组的过程，反序列化就是把字节数组再转换成Java对象的过程。
- 为什么建议自定义一个无参构造函数#card#Java
	- 1.反射及序列化要求
	- 在使用Java反射或者序列化/反序列化时，经常是调用类的无参构造函数进行对象创建的。
	- 2. 兼容性和可扩展性
	- 许多Java框架和库，如Spring、Hibernate、Jackson等，在进行对象的创建和初始化时，依赖于类的无参构造器。如果没有定义无参构造器，这些框架可能无法正常工作。
	- 3. JavaBean规范
	- 根据JavaBean规范，一个标准的JavaBean必须拥有一个公共的无参构造器。这使得JavaBean可以被实例化，并且其属性可以通过反射机制被外部访问和修改。
	- 4. 子类构造器的默认行为
	- 在Java中，子类构造器默认会调用父类的无参构造器。如果父类没有定义无参构造器，而子类又没有显式调用父类的其他构造器，这将导致编译错误。
- Java中的集合类有哪些？如何分类的？#card#Java
	- Java的整个集合框架中，主要分为List，Set，Queue，Stack，Map等五种数据结构。其中，前四种数据结构都是单一元素的集合，而最后的Map则是以KV对的形式使用。
	- 从继承关系上讲，List，Set，Queue都是Collection的子接口，Collection又继承了Iterable接口，说明这几种集合都是可以遍历的。
	- 从功能上讲，List代表一个容器，可以是先进先出，也可以是先进后出。而Set相对于List来说，是无序的，同时也是一个去重的列表，既然会去重，就一定会通过equals，compareTo，hashCode等方法进行比较。Map则是KV的映射，也会涉及到Key值的查询等能力。
- 你能说出几种集合的排序方式？#card#Java
	- 实现Comparable 接口比较
	- 借助Comparator比较器
	- 借助Stream的API
- 什么是fail-fast？什么是fail-safe？#card#Java
	- 快速失效(fail-fast)系统一种可以立即报告任何可能表明故障的情况的系统。快速失效系统通常设计用于停止正常操作，而不是试图继续可能存在缺陷的过程。
	- fail-safe 机制是为线程安全的集合准备的，可以避免像 fail-fast 一样在并发使用集合的时候，不断地抛出异常。
- Set是如何保证元素不重复的#card#Java
	- 在Java的Set体系中，根据实现方式不同主要分为两大类。HashSet和TreeSet。
		- TreeSet 是二叉树实现的，TreeSet中的数据是自动排好序的，不允许放入null值；底层基于TreeMap
		- HashSet 是哈希表实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束；底层基于HashMap
- ArrayList、LinkedList与Vector的区别？#card#Java
	- ArrayList 是一个可改变大小的数组.当更多的元素加入到ArrayList中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问,因为ArrayList本质上就是一个数组。
	- LinkedList 是一个双向链表，在添加和删除元素时具有比ArrayList更好的性能，但在get与set方面弱于ArrayList。
	- Vector 和ArrayList类似,但属于强同步类。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用ArrayList是更好的选择。
- HashMap、Hashtable和ConcurrentHashMap的区别？#card#Java
	- HashMap是非线程安全的。
	- Hashtable 中的方法是同步的，所以它是线程安全的。
	- ConcurrentHashMap在JDK 1.8之前使用分段锁保证线程安全， ConcurrentHashMap默认情况下将hash表分为16个桶（分片），在加锁的时候，针对每个单独的分片进行加锁，其他分片不受影响。锁的粒度更细，所以他的性能更好。
- 如何将集合变成线程安全的？#card#Java
	- 在调用集合前，使用synchronized或者ReentrantLock对代码加锁（读写都要加锁）
	- 使用ThreadLocal，将集合放到线程内访问，但是这样集合中的值就不能被其他线程访问了
	- 使用Collections.synchronizedXXX()方法，可以获得一个线程安全的集合
	- 使用不可变集合进行封装，当集合是不可变的时候，自然是线程安全的
- 如何让Java的线程池顺序执行任务？#card#Java
	- 1、使用单线程线程池
		- 我们可以使用SingleThreadExecutor这种线程池来执行任务，因为这个线程池中只有一个线程，所以他可以保证任务可以按照提交任务被顺序执行。
	- 2、使用有依赖关系的任务调度方式
	-