- finally中代码一定会执行吗？#card#Java
	- 通常情况下，finally的代码一定会被执行，但是这是有前提的：
		- 1、对应 try 语句块被执行，
		- 2、程序正常运行。
	- 发生以下情况，都会导致finally不会执行
		- 1、System.exit()方法被执行
		- 2、Runtime.getRuntime().halt()方法被执行
		- 3、try或者catch中有死循环
		- 4、操作系统强制杀掉了JVM进程，如执行了kill -9
		- 5、其他原因导致的虚拟机崩溃了
		- 6、虚拟机所运行的环境挂了，如计算机电源断了
- Java中的枚举有什么特点和好处#card#Java
	- 枚举的valueOf可以自动对入参进行非法参数的校验
	- 可以调用枚举中的方法，相对于普通的常量来说操作性更强
	- 枚举实现接口的话，可以很容易的实现策略模式
	- 枚举可以自带属性，扩展性更强
- 什么是AIO、BIO和NIO#card#Java
	- BIO （Blocking I/O）：同步阻塞I/O，是JDK1.4之前的传统IO模型。 线程发起IO请求后，一直阻塞，直到缓冲区数据就绪后，再进入下一步操作。
	- NIO （Non-Blocking I/O）：同步非阻塞IO，线程发起IO请求后，不需要阻塞，立即返回。用户线程不原地等待IO缓冲区，可以先做一些其他操作，只需要定时轮询检查IO缓冲区数据是否就绪即可。
	- AIO （ Asynchronous I/O）：异步非阻塞I/O模型。线程发起IO请求后，不需要阻塞，立即返回，也不需要定时轮询检查结果，异步IO操作之后会回调通知调用方。
- Java是值传递还是引用传递#card#Java
	- 值传递
- JDK新版本中都有哪些新特性#card#Java
	- JDK 8中推出了Lambda表达式、Stream、Optional、新的日期API等
	- JDK 9中推出了模块化
	- JDK 10中推出了本地变量类型推断
	- JDK 12中增加了switch表达式
	- JDK 13中增加了text block
	- JDK 14中增加了Records
	- JDK 14中增加了instance模式匹配
	- JDK 15中增加了封闭类
	- JDK 17中扩展了switch模式匹配
	- JDK 21中增加了协程
- String是如何实现不可变的#card#Java
	- String类被声明为final，这意味着它不能被继承。那么他里面的方法就是没办法被覆盖的。
	- 用final修饰字符串内容的char[]（从JDK 1.9开始，char[]变成了byte[]），由于该数组被声明为final，一旦数组被初始化，就不能再指向其他数组。
	- String类没有提供用于修改字符串内容的公共方法。例如，没有提供用于追加、删除或修改字符的方法。如果需要对字符串进行修改，会创建一个新的String对象。
- 什么是序列化与反序列化#card#Java
	- 序列化就是把Java对象序列化成字节数组的过程，反序列化就是把字节数组再转换成Java对象的过程。
- 为什么建议自定义一个无参构造函数#card#Java
	- 1.反射及序列化要求
	- 在使用Java反射或者序列化/反序列化时，经常是调用类的无参构造函数进行对象创建的。
	- 2. 兼容性和可扩展性
	- 许多Java框架和库，如Spring、Hibernate、Jackson等，在进行对象的创建和初始化时，依赖于类的无参构造器。如果没有定义无参构造器，这些框架可能无法正常工作。
	- 3. JavaBean规范
	- 根据JavaBean规范，一个标准的JavaBean必须拥有一个公共的无参构造器。这使得JavaBean可以被实例化，并且其属性可以通过反射机制被外部访问和修改。
	- 4. 子类构造器的默认行为
	- 在Java中，子类构造器默认会调用父类的无参构造器。如果父类没有定义无参构造器，而子类又没有显式调用父类的其他构造器，这将导致编译错误。
- Java中的集合类有哪些？如何分类的？#card#Java
	- Java的整个集合框架中，主要分为List，Set，Queue，Stack，Map等五种数据结构。其中，前四种数据结构都是单一元素的集合，而最后的Map则是以KV对的形式使用。
	- 从继承关系上讲，List，Set，Queue都是Collection的子接口，Collection又继承了Iterable接口，说明这几种集合都是可以遍历的。
	- 从功能上讲，List代表一个容器，可以是先进先出，也可以是先进后出。而Set相对于List来说，是无序的，同时也是一个去重的列表，既然会去重，就一定会通过equals，compareTo，hashCode等方法进行比较。Map则是KV的映射，也会涉及到Key值的查询等能力。
- 你能说出几种集合的排序方式？#card#Java
	- 实现Comparable 接口比较
	- 借助Comparator比较器
	- 借助Stream的API
- 什么是fail-fast？什么是fail-safe？#card#Java
	- 快速失效(fail-fast)系统一种可以立即报告任何可能表明故障的情况的系统。快速失效系统通常设计用于停止正常操作，而不是试图继续可能存在缺陷的过程。
	- fail-safe 机制是为线程安全的集合准备的，可以避免像 fail-fast 一样在并发使用集合的时候，不断地抛出异常。
- Set是如何保证元素不重复的#card#Java
	- 在Java的Set体系中，根据实现方式不同主要分为两大类。HashSet和TreeSet。
		- TreeSet 是二叉树实现的，TreeSet中的数据是自动排好序的，不允许放入null值；底层基于TreeMap
		- HashSet 是哈希表实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束；底层基于HashMap
- ArrayList、LinkedList与Vector的区别？#card#Java
	- ArrayList 是一个可改变大小的数组.当更多的元素加入到ArrayList中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问,因为ArrayList本质上就是一个数组。
	- LinkedList 是一个双向链表，在添加和删除元素时具有比ArrayList更好的性能，但在get与set方面弱于ArrayList。
	- Vector 和ArrayList类似,但属于强同步类。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用ArrayList是更好的选择。
- HashMap、Hashtable和ConcurrentHashMap的区别？#card#Java
	- HashMap是非线程安全的。
	- Hashtable 中的方法是同步的，所以它是线程安全的。
	- ConcurrentHashMap在JDK 1.8之前使用分段锁保证线程安全， ConcurrentHashMap默认情况下将hash表分为16个桶（分片），在加锁的时候，针对每个单独的分片进行加锁，其他分片不受影响。锁的粒度更细，所以他的性能更好。
- 如何将集合变成线程安全的？#card#Java
	- 在调用集合前，使用synchronized或者ReentrantLock对代码加锁（读写都要加锁）
	- 使用ThreadLocal，将集合放到线程内访问，但是这样集合中的值就不能被其他线程访问了
	- 使用Collections.synchronizedXXX()方法，可以获得一个线程安全的集合
	- 使用不可变集合进行封装，当集合是不可变的时候，自然是线程安全的
- 如何让Java的线程池顺序执行任务？#card#Java
	- 1、使用单线程线程池
		- 我们可以使用SingleThreadExecutor这种线程池来执行任务，因为这个线程池中只有一个线程，所以他可以保证任务可以按照提交任务被顺序执行。
	- 2、使用有依赖关系的任务调度方式
		- 可以使用ScheduledThreadPoolExecutor结合ScheduledFuture来实现任务的顺序执行。将任务按照顺序提交给线程池，每个任务的执行时间通过ScheduledFuture的get()方法等待前一个任务完成。
- 什么是多线程中的上下文切换？#card#Java
	- 上下文切换是指 CPU 从一个线程转到另一个线程时，需要保存当前线程的上下文状态，恢复另一个线程的上下文状态，以便于下一次恢复执行该线程时能够正确地运行。
- 能不能谈谈你对线程安全的理解？#card#Java
	- 简单来说，就是多个线程同时访问共享变量的时候，得到的结果和我们预期的一样，就是线程安全。所以有四个关键词：并发、多线程、共享变量、正确完成。这里所谓的正确完成，其实就是要满足所谓的原子性、有序性和可见性。
- 什么是并发，什么是并行？#card#Java
	- 并发（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。
	- 并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。
- 线程有几种状态，状态之间的流转是怎样的？#card#Java
	- Java中线程的状态分为6种
		- 1.初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
		- 2.运行(RUNNABLE)：Java线程中将就绪（READY）和运行中（RUNNING）两种状态笼统的称为“运行”。
		- 就绪（READY）:线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中并分配cpu使用权 。
		- 运行中（RUNNING）：就绪(READY)的线程获得了cpu 时间片，开始执行程序代码。
		- 3.阻塞(BLOCKED)：表示线程阻塞于锁（关于锁，在后面章节会介绍）。
		- 4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
		- 5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
		- 6. 终止(TERMINATED)：表示该线程已经执行完毕。
		- 如图所示
		- ![](https://work-1306904200.cos.ap-nanjing.myqcloud.com/1703596501381-ac42214e-f6fa-44ce-a54e-20fc90606afb.png)
- 创建线程有几种方式？#card#Java
	- 继承Thread类创建线程
	- 实现Runnable接口创建线程
	- 通过Callable和FutureTask创建线程
	- 通过线程池创建线程
- run/start、wait/sleep、notify/notifyAll区别?#card#Java
	- run方法和start方法区别
		- start方法是启动一个线程的入口。
		- 直接调用其run方法，那么就会在单线程中直接运行run方法，不会起到多线程的效果
	- sleep和wait区别
		- sleep()方法可以在任何地方使用；而wait()方法则只能在同步方法或同步块中使用
		- wait 方法会释放对象锁，但 sleep 方法不会。
		- wait的线程会进入到WAITING状态，直到被唤醒；sleep的线程会进入到TIMED_WAITING状态，等到指定时间之后会再尝试获取CPU时间片。
	- notify和notifyAll区别
		- 使用notifyAll，可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。
- 什么是线程池，如何实现的？#card#Java
	- 线程池，说的就是提前创建好一批线程，然后保存在线程池中，当有任务需要执行的时候，从线程池中选一个线程来执行任务。
- 线程数设定成多少更合适？#card#Java
	- 如果是CPU密集型应用，则线程池大小设置为N+1
	- 如果是IO密集型应用，则线程池大小设置为2N+1
- 什么是ThreadLocal，如何实现的？#card#Java
	- ThreadLocal是java.lang下面的一个类，是用来解决java多线程程序中并发问题的一种途径；通过为每一个线程创建一份共享变量的副本来保证各个线程之间的变量的访问和修改互相不影响；
	- ThreadLocal有四个方法，分别为：
		- initialValue：返回此线程局部变量的初始值
		- get：返回此线程局部变量的当前线程副本中的值。如果这是线程第一次调用该方法，则创建并初始化此副本。
		- set：将此线程局部变量的当前线程副本中的值设置为指定值。许多应用程序不需要这项功能，它们只依赖于 initialValue() 方法来设置线程局部变量的值。
		- remove：移除此线程局部变量的值。
- 什么是死锁，如何解决？#card#Java
	- 死锁是指两个或两个以上的进程（或线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
	- 解决方式：
		- 保证操作的顺序，比如多个事务都是先操作资源A、再操作资源B，这样就能有效的避免死锁。
- synchronized锁的是什么#card#Java
	- 对象
- 公平锁和非公平锁的区别？#card#Java
	- 非公平锁：多个线程不按照申请锁的顺序去获得锁，而是直接去尝试获取锁，获取不到，再进入队列等待，如果能获取到，就直接获取到锁。
	- 公平锁：多个线程按照申请锁的顺序去获得锁，所有线程都在队列里排队，这样就保证了队列中的第一个先得到锁。
- CountDownLatch、CyclicBarrier、Semaphore区别？#card#Java
	- CountDownLatch是一个计数器，它允许一个或多个线程等待其他线程完成操作。它通常用来实现一个线程等待其他多个线程完成操作之后再继续执行的操作。
	- CyclicBarrier是一个同步屏障，它允许多个线程相互等待，直到到达某个公共屏障点，才能继续执行。它通常用来实现多个线程在同一个屏障处等待，然后再一起继续执行的操作。
	- Semaphore是一个计数信号量，它允许多个线程同时访问共享资源，并通过计数器来控制访问数量。它通常用来实现一个线程需要等待获取一个许可证才能访问共享资源，或者需要释放一个许可证才能完成操作的操作。
- ForkJoinPool和ThreadPoolExecutor区别是什么？#card#Java
	- 首先在实现方式上，ForkJoinPool 是基于工作窃取（Work-Stealing）算法实现的线程池，ForkJoinPool 中每个线程都有自己的工作队列，用于存储待执行的任务。当一个线程执行完自己的任务之后，会从其他线程的工作队列中窃取任务执行，以此来实现任务的动态均衡和线程的利用率最大化。
	- ThreadPoolExecutor 是基于任务分配（Task-Assignment）算法实现的线程池，ThreadPoolExecutor 中线程池中有一个共享的工作队列，所有任务都将提交到这个队列中。线程池中的线程会从队列中获取任务执行，如果队列为空，则线程会等待，直到队列中有任务为止。
	- ForkJoinPool 中的任务通常是一些可以分割成多个子任务的任务，例如快速排序。每个任务都可以分成两个或多个子任务，然后由不同的线程来执行这些子任务。在这个过程中，ForkJoinPool 会自动管理任务的执行、分割和合并，从而实现任务的动态分配和最优化执行。、
- ForkJoinPool 适用场景#card#Java
	-
	- 大任务分解为小任务：适用于可以递归分解为更小任务的大型任务。ForkJoinPool 通过分而治之的方式，将大任务拆分为小任务，这些小任务可以并行处理。
	- 计算密集型任务：对于需要大量计算且能够并行化的任务，ForkJoinPool 是一个理想的选择。它能够有效利用多核处理器的优势来加速处理过程。
	- 异构任务并行处理：当任务之间没有或很少有依赖性时，ForkJoinPool 可以帮助并行执行这些任务，从而提高效率。
	- 递归算法的并行化：适合于可以用递归方法解决的问题，如快速排序、归并排序、图像处理中的分区算法等。
	- 数据聚合任务：在处理需要聚合多个数据源结果的任务时（例如，遍历树结构并聚合结果），ForkJoinPool 提供了有效的方式来并行化这一过程。
- Thread.sleep(0)的作用是什么？#card#Java
	- 这种用法其实就是让当前线程释放一下CPU时间片，然后重新开始争抢。
- 有哪些实现线程安全的方案?#card#Java
	- 1、单线程
	- 2、互斥锁
	- 3、读写分离
	- 4、原子操作
	- 5、不可变模式
	- 6、数据不共享
- 线程池的拒绝策略有哪些？#card#Java
	-
	- AbortPolicy - 这是默认的拒绝策略，当线程池无法接受新任务时，会抛出RejectedExecutionException异常。这意味着新任务会被立即拒绝，不会加入到任务队列中，也不会执行。通常情况下都是使用这种拒绝策略。
	- DiscardPolicy - 这个策略在任务队列已满时，会丢弃新的任务而且不会抛出异常。新任务提交后会被默默地丢弃，不会有任何提示或执行。这个策略一般用于日志记录、统计等不是非常关键的任务。
	- DiscardOldestPolicy - 这个策略也会丢弃任务，但它会先尝试将任务队列中最早的任务删除，然后再尝试提交新任务。如果任务队列已满，且线程池中的线程都在工作，可能会导致一些任务被丢弃。这个策略对于一些实时性要求较高的场景比较合适。
	- CallerRunsPolicy - 这个策略将任务回退给调用线程，而不会抛出异常。调用线程会尝试执行任务。这个策略可以降低任务提交速度，适用于任务提交者能够承受任务执行的压力，但希望有一种缓冲机制的情况。
- 介绍一下Spring的IOC#card#Java
	- 所谓的IOC（inversion of control），就是控制反转的意思。何为控制反转？
	- 在IOC 中，控制关系发生了反转。控制权被转移到Spring容器中，容器负责创建和管理对象，并在需要的时候将它们注入到应用程序中。
- IOC是如何实现的？#card#Java
	- 从配置元数据中获取要DI的业务POJO（这里的配置元数据包括xml，注解，configuration类等）
	- 将业务POJO形成BeanDefinition注入到Spring Container中
	- 使用方通过ApplicationContext从Spring Container直接获取即可。如下图所示：
	- ![](https://work-1306904200.cos.ap-nanjing.myqcloud.com/1673667342516-9f823f13-c1fe-41e2-85e1-f0764ed7cbbe.png)
- 介绍一下Spring的AOP#card#Java
	- 和IOC一样，AOP也指的是一种思想。AOP思想是OOP（Object-Oriented Programming）的补充。OOP是面向类和对象的，但是AOP则是面向不同切面的。一个切面可以横跨多个类和对象去操作，极大的丰富了开发者的使用方式，提高了开发效率。
- Spring Bean的初始化过程是怎么样的？#card#Java
	- 实例化Bean: 容器会在调用createBeanInstance之前检查Bean定义的作用域。如果是Singleton，容器会在其内部单例缓存中查找现有实例。如果实例已存在，它将被重用；如果不存在，才会调用createBeanInstance来创建新的实例。
	- 设置属性值: