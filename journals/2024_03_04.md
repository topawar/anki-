- finally中代码一定会执行吗？#card#Java
	- 通常情况下，finally的代码一定会被执行，但是这是有前提的：
		- 1、对应 try 语句块被执行，
		- 2、程序正常运行。
	- 发生以下情况，都会导致finally不会执行
		- 1、System.exit()方法被执行
		- 2、Runtime.getRuntime().halt()方法被执行
		- 3、try或者catch中有死循环
		- 4、操作系统强制杀掉了JVM进程，如执行了kill -9
		- 5、其他原因导致的虚拟机崩溃了
		- 6、虚拟机所运行的环境挂了，如计算机电源断了
- Java中的枚举有什么特点和好处#card#Java
	- 枚举的valueOf可以自动对入参进行非法参数的校验
	- 可以调用枚举中的方法，相对于普通的常量来说操作性更强
	- 枚举实现接口的话，可以很容易的实现策略模式
	- 枚举可以自带属性，扩展性更强
- 什么是AIO、BIO和NIO#card#Java
	- BIO （Blocking I/O）：同步阻塞I/O，是JDK1.4之前的传统IO模型。 线程发起IO请求后，一直阻塞，直到缓冲区数据就绪后，再进入下一步操作。
	- NIO （Non-Blocking I/O）：同步非阻塞IO，线程发起IO请求后，不需要阻塞，立即返回。用户线程不原地等待IO缓冲区，可以先做一些其他操作，只需要定时轮询检查IO缓冲区数据是否就绪即可。
	- AIO （ Asynchronous I/O）：异步非阻塞I/O模型。线程发起IO请求后，不需要阻塞，立即返回，也不需要定时轮询检查结果，异步IO操作之后会回调通知调用方。
- Java是值传递还是引用传递#card#Java
	- 值传递
- JDK新版本中都有哪些新特性#card#Java
	- JDK 8中推出了Lambda表达式、Stream、Optional、新的日期API等
	- JDK 9中推出了模块化
	- JDK 10中推出了本地变量类型推断
	- JDK 12中增加了switch表达式
	- JDK 13中增加了text block
	- JDK 14中增加了Records
	- JDK 14中增加了instance模式匹配
	- JDK 15中增加了封闭类
	- JDK 17中扩展了switch模式匹配
	- JDK 21中增加了协程
- String是如何实现不可变的#card#Java
	- String类被声明为final，这意味着它不能被继承。那么他里面的方法就是没办法被覆盖的。
	- 用final修饰字符串内容的char[]（从JDK 1.9开始，char[]变成了byte[]），由于该数组被声明为final，一旦数组被初始化，就不能再指向其他数组。
	- String类没有提供用于修改字符串内容的公共方法。例如，没有提供用于追加、删除或修改字符的方法。如果需要对字符串进行修改，会创建一个新的String对象。
- 什么是序列化与反序列化#card#Java
	- 序列化就是把Java对象序列化成字节数组的过程，反序列化就是把字节数组再转换成Java对象的过程。
- 为什么建议自定义一个无参构造函数#card#Java
	- 1.反射及序列化要求
	- 在使用Java反射或者序列化/反序列化时，经常是调用类的无参构造函数进行对象创建的。
	- 2. 兼容性和可扩展性
	- 许多Java框架和库，如Spring、Hibernate、Jackson等，在进行对象的创建和初始化时，依赖于类的无参构造器。如果没有定义无参构造器，这些框架可能无法正常工作。
	- 3. JavaBean规范
	- 根据JavaBean规范，一个标准的JavaBean必须拥有一个公共的无参构造器。这使得JavaBean可以被实例化，并且其属性可以通过反射机制被外部访问和修改。
	- 4. 子类构造器的默认行为
	- 在Java中，子类构造器默认会调用父类的无参构造器。如果父类没有定义无参构造器，而子类又没有显式调用父类的其他构造器，这将导致编译错误。
- Java中的集合类有哪些？如何分类的？#card#Java
	- Java的整个集合框架中，主要分为List，Set，Queue，Stack，Map等五种数据结构。其中，前四种数据结构都是单一元素的集合，而最后的Map则是以KV对的形式使用。
	- 从继承关系上讲，List，Set，Queue都是Collection的子接口，Collection又继承了Iterable接口，说明这几种集合都是可以遍历的。
	- 从功能上讲，List代表一个容器，可以是先进先出，也可以是先进后出。而Set相对于List来说，是无序的，同时也是一个去重的列表，既然会去重，就一定会通过equals，compareTo，hashCode等方法进行比较。Map则是KV的映射，也会涉及到Key值的查询等能力。
- 你能说出几种集合的排序方式？#card#Java
	- 实现Comparable 接口比较
	- 借助Comparator比较器
	- 借助Stream的API
- 什么是fail-fast？什么是fail-safe？#card#Java
	- 快速失效(fail-fast)系统一种可以立即报告任何可能表明故障的情况的系统。快速失效系统通常设计用于停止正常操作，而不是试图继续可能存在缺陷的过程。
	- fail-safe 机制是为线程安全的集合准备的，可以避免像 fail-fast 一样在并发使用集合的时候，不断地抛出异常。
- Set是如何保证元素不重复的#card#Java
	- 在Java的Set体系中，根据实现方式不同主要分为两大类。HashSet和TreeSet。
		- TreeSet 是二叉树实现的，TreeSet中的数据是自动排好序的，不允许放入null值；底层基于TreeMap
		- HashSet 是哈希表实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束；底层基于HashMap
- ArrayList、LinkedList与Vector的区别？#card#Java
	- ArrayList 是一个可改变大小的数组.当更多的元素加入到ArrayList中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问,因为ArrayList本质上就是一个数组。
	- LinkedList 是一个双向链表，在添加和删除元素时具有比ArrayList更好的性能，但在get与set方面弱于ArrayList。
	- Vector 和ArrayList类似,但属于强同步类。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用ArrayList是更好的选择。
- HashMap、Hashtable和ConcurrentHashMap的区别？#card#Java
	- HashMap是非线程安全的。
	- Hashtable 中的方法是同步的，所以它是线程安全的。
	- ConcurrentHashMap在JDK 1.8之前使用分段锁保证线程安全， ConcurrentHashMap默认情况下将hash表分为16个桶（分片），在加锁的时候，针对每个单独的分片进行加锁，其他分片不受影响。锁的粒度更细，所以他的性能更好。
- 如何将集合变成线程安全的？#card#Java
	- 在调用集合前，使用synchronized或者ReentrantLock对代码加锁（读写都要加锁）
	- 使用ThreadLocal，将集合放到线程内访问，但是这样集合中的值就不能被其他线程访问了
	- 使用Collections.synchronizedXXX()方法，可以获得一个线程安全的集合
	- 使用不可变集合进行封装，当集合是不可变的时候，自然是线程安全的
- 如何让Java的线程池顺序执行任务？#card#Java
	- 1、使用单线程线程池
		- 我们可以使用SingleThreadExecutor这种线程池来执行任务，因为这个线程池中只有一个线程，所以他可以保证任务可以按照提交任务被顺序执行。
	- 2、使用有依赖关系的任务调度方式
		- 可以使用ScheduledThreadPoolExecutor结合ScheduledFuture来实现任务的顺序执行。将任务按照顺序提交给线程池，每个任务的执行时间通过ScheduledFuture的get()方法等待前一个任务完成。
- 什么是多线程中的上下文切换？#card#Java
	- 上下文切换是指 CPU 从一个线程转到另一个线程时，需要保存当前线程的上下文状态，恢复另一个线程的上下文状态，以便于下一次恢复执行该线程时能够正确地运行。
- 能不能谈谈你对线程安全的理解？#card#Java
	- 简单来说，就是多个线程同时访问共享变量的时候，得到的结果和我们预期的一样，就是线程安全。所以有四个关键词：并发、多线程、共享变量、正确完成。这里所谓的正确完成，其实就是要满足所谓的原子性、有序性和可见性。
- 什么是并发，什么是并行？#card#Java
	- 并发（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。
	- 并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。
- 线程有几种状态，状态之间的流转是怎样的？#card#Java
	- Java中线程的状态分为6种
		- 1.初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
		- 2.运行(RUNNABLE)：Java线程中将就绪（READY）和运行中（RUNNING）两种状态笼统的称为“运行”。
		- 就绪（READY）:线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中并分配cpu使用权 。
		- 运行中（RUNNING）：就绪(READY)的线程获得了cpu 时间片，开始执行程序代码。
		- 3.阻塞(BLOCKED)：表示线程阻塞于锁（关于锁，在后面章节会介绍）。
		- 4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
		- 5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
		- 6. 终止(TERMINATED)：表示该线程已经执行完毕。
		- 如图所示
		- ![](https://work-1306904200.cos.ap-nanjing.myqcloud.com/1703596501381-ac42214e-f6fa-44ce-a54e-20fc90606afb.png)
- 创建线程有几种方式？#card#Java
	- 继承Thread类创建线程
	- 实现Runnable接口创建线程
	- 通过Callable和FutureTask创建线程
	- 通过线程池创建线程
- run/start、wait/sleep、notify/notifyAll区别?#card#Java
	- run方法和start方法区别
		- start方法是启动一个线程的入口。
		- 直接调用其run方法，那么就会在单线程中直接运行run方法，不会起到多线程的效果
	- sleep和wait区别
		- sleep()方法可以在任何地方使用；而wait()方法则只能在同步方法或同步块中使用
		- wait 方法会释放对象锁，但 sleep 方法不会。
		- wait的线程会进入到WAITING状态，直到被唤醒；sleep的线程会进入到TIMED_WAITING状态，等到指定时间之后会再尝试获取CPU时间片。
	- notify和notifyAll区别
		- 使用notifyAll，可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。
- 什么是线程池，如何实现的？#card#Java
	- 线程池，说的就是提前创建好一批线程，然后保存在线程池中，当有任务需要执行的时候，从线程池中选一个线程来执行任务。
- 线程数设定成多少更合适？#card#Java
	- 如果是CPU密集型应用，则线程池大小设置为N+1
	- 如果是IO密集型应用，则线程池大小设置为2N+1
- 什么是ThreadLocal，如何实现的？#card#Java
	- ThreadLocal是java.lang下面的一个类，是用来解决java多线程程序中并发问题的一种途径；通过为每一个线程创建一份共享变量的副本来保证各个线程之间的变量的访问和修改互相不影响；
	- ThreadLocal有四个方法，分别为：
		- initialValue：返回此线程局部变量的初始值
		- get：返回此线程局部变量的当前线程副本中的值。如果这是线程第一次调用该方法，则创建并初始化此副本。
		- set：将此线程局部变量的当前线程副本中的值设置为指定值。许多应用程序不需要这项功能，它们只依赖于 initialValue() 方法来设置线程局部变量的值。
		- remove：移除此线程局部变量的值。
- 什么是死锁，如何解决？#card#Java
	- 死锁是指两个或两个以上的进程（或线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
	- 解决方式：
		- 保证操作的顺序，比如多个事务都是先操作资源A、再操作资源B，这样就能有效的避免死锁。
- synchronized锁的是什么#card#Java
	- 对象
- 公平锁和非公平锁的区别？#card#Java
	- 非公平锁：多个线程不按照申请锁的顺序去获得锁，而是直接去尝试获取锁，获取不到，再进入队列等待，如果能获取到，就直接获取到锁。
	- 公平锁：多个线程按照申请锁的顺序去获得锁，所有线程都在队列里排队，这样就保证了队列中的第一个先得到锁。
- CountDownLatch、CyclicBarrier、Semaphore区别？#card#Java
	- CountDownLatch是一个计数器，它允许一个或多个线程等待其他线程完成操作。它通常用来实现一个线程等待其他多个线程完成操作之后再继续执行的操作。
	- CyclicBarrier是一个同步屏障，它允许多个线程相互等待，直到到达某个公共屏障点，才能继续执行。它通常用来实现多个线程在同一个屏障处等待，然后再一起继续执行的操作。
	- Semaphore是一个计数信号量，它允许多个线程同时访问共享资源，并通过计数器来控制访问数量。它通常用来实现一个线程需要等待获取一个许可证才能访问共享资源，或者需要释放一个许可证才能完成操作的操作。
- ForkJoinPool和ThreadPoolExecutor区别是什么？#card#Java
	- 首先在实现方式上，ForkJoinPool 是基于工作窃取（Work-Stealing）算法实现的线程池，ForkJoinPool 中每个线程都有自己的工作队列，用于存储待执行的任务。当一个线程执行完自己的任务之后，会从其他线程的工作队列中窃取任务执行，以此来实现任务的动态均衡和线程的利用率最大化。
	- ThreadPoolExecutor 是基于任务分配（Task-Assignment）算法实现的线程池，ThreadPoolExecutor 中线程池中有一个共享的工作队列，所有任务都将提交到这个队列中。线程池中的线程会从队列中获取任务执行，如果队列为空，则线程会等待，直到队列中有任务为止。
	- ForkJoinPool 中的任务通常是一些可以分割成多个子任务的任务，例如快速排序。每个任务都可以分成两个或多个子任务，然后由不同的线程来执行这些子任务。在这个过程中，ForkJoinPool 会自动管理任务的执行、分割和合并，从而实现任务的动态分配和最优化执行。、
- ForkJoinPool 适用场景#card#Java
	-
	- 大任务分解为小任务：适用于可以递归分解为更小任务的大型任务。ForkJoinPool 通过分而治之的方式，将大任务拆分为小任务，这些小任务可以并行处理。
	- 计算密集型任务：对于需要大量计算且能够并行化的任务，ForkJoinPool 是一个理想的选择。它能够有效利用多核处理器的优势来加速处理过程。
	- 异构任务并行处理：当任务之间没有或很少有依赖性时，ForkJoinPool 可以帮助并行执行这些任务，从而提高效率。
	- 递归算法的并行化：适合于可以用递归方法解决的问题，如快速排序、归并排序、图像处理中的分区算法等。
	- 数据聚合任务：在处理需要聚合多个数据源结果的任务时（例如，遍历树结构并聚合结果），ForkJoinPool 提供了有效的方式来并行化这一过程。
- Thread.sleep(0)的作用是什么？#card#Java
	- 这种用法其实就是让当前线程释放一下CPU时间片，然后重新开始争抢。
- 有哪些实现线程安全的方案?#card#Java
	- 1、单线程
	- 2、互斥锁
	- 3、读写分离
	- 4、原子操作
	- 5、不可变模式
	- 6、数据不共享
- 线程池的拒绝策略有哪些？#card#Java
	-
	- AbortPolicy - 这是默认的拒绝策略，当线程池无法接受新任务时，会抛出RejectedExecutionException异常。这意味着新任务会被立即拒绝，不会加入到任务队列中，也不会执行。通常情况下都是使用这种拒绝策略。
	- DiscardPolicy - 这个策略在任务队列已满时，会丢弃新的任务而且不会抛出异常。新任务提交后会被默默地丢弃，不会有任何提示或执行。这个策略一般用于日志记录、统计等不是非常关键的任务。
	- DiscardOldestPolicy - 这个策略也会丢弃任务，但它会先尝试将任务队列中最早的任务删除，然后再尝试提交新任务。如果任务队列已满，且线程池中的线程都在工作，可能会导致一些任务被丢弃。这个策略对于一些实时性要求较高的场景比较合适。
	- CallerRunsPolicy - 这个策略将任务回退给调用线程，而不会抛出异常。调用线程会尝试执行任务。这个策略可以降低任务提交速度，适用于任务提交者能够承受任务执行的压力，但希望有一种缓冲机制的情况。
- 介绍一下Spring的IOC#card#Java
	- 所谓的IOC（inversion of control），就是控制反转的意思。何为控制反转？
	- 在IOC 中，控制关系发生了反转。控制权被转移到Spring容器中，容器负责创建和管理对象，并在需要的时候将它们注入到应用程序中。
- IOC是如何实现的？#card#Java
	- 从配置元数据中获取要DI的业务POJO（这里的配置元数据包括xml，注解，configuration类等）
	- 将业务POJO形成BeanDefinition注入到Spring Container中
	- 使用方通过ApplicationContext从Spring Container直接获取即可。如下图所示：
	- ![](https://work-1306904200.cos.ap-nanjing.myqcloud.com/1673667342516-9f823f13-c1fe-41e2-85e1-f0764ed7cbbe.png)
- 介绍一下Spring的AOP#card#Java
	- 和IOC一样，AOP也指的是一种思想。AOP思想是OOP（Object-Oriented Programming）的补充。OOP是面向类和对象的，但是AOP则是面向不同切面的。一个切面可以横跨多个类和对象去操作，极大的丰富了开发者的使用方式，提高了开发效率。
- Spring Bean的初始化过程是怎么样的？#card#Java
	- 实例化Bean: 容器会在调用createBeanInstance之前检查Bean定义的作用域。如果是Singleton，容器会在其内部单例缓存中查找现有实例。如果实例已存在，它将被重用；如果不存在，才会调用createBeanInstance来创建新的实例。
	- 设置属性值:populateBean方法是Spring Bean生命周期中的一个关键部分，负责将属性值应用到新创建的Bean实例。
	- initializeBean方法
- Spring的事务传播机制有哪些？#card#Java
	- Spring的事务规定了7种事务的传播级别，默认的传播机制是REQUIRED
	- ●REQUIRED，如果不存在事务则开启一个事务，如果存在事务则加入之前的事务，总是只有一个事务在执行
	- ●REQUIRES_NEW，每次执行新开一个事务
	- ●SUPPORTS，有事务则加入事务，没有事务则普通执行
	- ●NOT_SUPPORTED，有事务则暂停该事务，没有则普通执行
	- ●MANDATORY，强制有事务，没有事务则报异常
	- ●NEVER，有事务则报异常
	- ●NESTED，如果之前有事务，则创建嵌套事务，嵌套事务回滚不影响父事务，反之父事务影响嵌套事务
- Autowired和Resource的关系？#card#Java
	- byName和byType匹配顺序不同
		- Autowired在获取bean的时候，先是byType的方式，再是byName的方式。意思就是先在Spring容器中找以Bean为类型的Bean实例，如果找不到或者找到多个bean，则会通过fieldName来找。
		- Resource在获取bean的时候，和Autowired恰好相反，先是byName方式，然后再是byType方式。
	- 作用域不同
		- Autowired可以作用在构造器，字段，setter方法上
		- Resource 只可以使用在field，setter方法上
	- 支持方不同
		- Autowired是Spring提供的自动注入注解，只有Spring容器会支持，如果做容器迁移，是需要修改代码的
		- Resource是JDK官方提供的自动注入注解（JSR-250）。它等于说是一个标准或者约定，所有的IOC容器都会支持这个注解。假如系统容器从Spring迁移到其他IOC容器中，是不需要修改代码的。
- BeanFactory和FactroyBean的关系？#card#Java
	- BeanFactory比较常用，名字也比较容易理解，就是Bean工厂，他是整个Spring IoC容器的一部分，负责管理Bean的创建和生命周期。
	- FactoryBean 是一个接口，允许你实现自定义的 bean 工厂，用于创建其他 bean 的实例，并添加更多的自定义逻辑。
- Spring中如何开启事务？#card#Java
	- 基于底层的API，如PlatformTransactionManager、TransactionDefinition 和 TransactionTemplate 等核心接口，开发者完全可以通过编程的方式来进行事务管理。
	- 声明式事务管理方法允许开发者配置的帮助下来管理事务，而不需要依赖底层API进行硬编码。开发者可以只使用注解或基于配置的 XML 来管理事务。
- Spring中用到了哪些设计模式#card#Java
	- [工厂模式](https://www.yuque.com/hollis666/vagnu8/trigus)
	- 组合模式
	- 适配器模式
	- 代理模式
	- 单例模式
	- 观察者模式
	- 模板方法模式
	- 责任链模式
- 什么是Spring的循环依赖问题？#card#Java
	- 在Spring框架中，循环依赖是指两个或多个bean之间相互依赖，形成了一个循环引用的情况。
- Spring事务失效可能是哪些原因？#card#Java
	- 1、@Transactional 应用在非 public 修饰的方法上
	- 2、同一个类中方法调用，导致@Transactional失效
	- 3、final、static方法
	- @Transactional用的不对
		- @Transactional 注解属性 rollbackFor 设置错误
		- 用错注解
		- 异常被catch捕获导致@Transactional失效
		- 数据库引擎不支持事务
- 什么是MVC#card#Java
	- MVC是指Model-View-Controller，是一种软件设计模式，它将应用程序分为三个部分：模型、视图和控制器。这个模式的目的是将应用程序的表示（视图）与处理（控制器）分开，以及将应用程序的数据和业务逻辑（模型）与表示和处理分开。
- SpringMVC是如何将不同的Request路由到不同Controller中的#card#Java
	- Spring MVC在启动的时候，会把带有@RequestMapping注解的方法和类封装成一个RequestMappingInfo和HandlerMethod，然后注册到MappingRegistry。当HttpServletRequest访问时，会通过AbstractHandlerMethodMapping的lookupHandlerMethod方法获取对应的HandlerMethod
- SpringMVC的执行流程是什么样的？#card#Java
	- 先通过HandlerMapping拿到request对应的HandlerExecutionChain，然后再拿到HandlerExecutionChain中handler对应的HandlerAdapter，执行HandlerExecutionChain中interceptor的prehandle方法。（责任链模式）
	- 再通过HandlerAdapter去执行handler，handler其实对应的是之前注册的HandlerMethod（handlerMethod里面封装的映射的真正方法 handler还有可能是原生的Servlet），所以要执行handler.invoke，不过在这之前要去判断参数，这一步需要参数解析器HandlerMethodArgumentResolver。反射调用完之后，需要调用返回值解析器HandlerMethodReturnValueHanlder（适配器模式&组合模式&策略模式）
	- 真正方法执行完了之后，再执行HandlerExecutionChain中interceptor的posthandle方法进行拦截器的后置处理。
	- SpringMVC执行完之后返回的是ModelAndView，我们还需要对ModelAndView进行render，即把ModelAndView中的view渲染到response中
	- 当发生异常时，会将异常拉到用户业务自己的异常处理方法中，这时也需要对参数和返回值进行custom，此时就需要用到HandlerExceptionResolver系列了。因为用户标记的@ExceptionHandler方法已经被ExceptionHandlerMethodResolver找到并且注册（key为对应异常，value为对应方法），只需要调用该方法就可以对异常进行处理，此时的方法调用和之前的handler几乎没有区别
- 如何统计一个Bean中的方法调用次数#card#Java
	- 通过aop
- Spring的AOP在什么场景下会失效？#card#Java
	- >首先，Spring的AOP其实是通过动态代理实现的，所以，想要让AOP生效，前提必须是动态代理生效，并且可以调用到代理对象的方法。
		- 什么情况下会不走代理对象的调用呢？
			- 1、私有方法调用
			- 2、静态方法调用
			- 3、final方法调用
			- 4、类内部自调用
			- 5、内部类方法调用
- 为什么不建议直接使用Spring的@Async#card#Java
	- @Async中关于线程池的使用部分在AsyncExecutionInterceptor中，在这个类中有一个getDefaultExecutor方法， 当我们没有做过自定义线程池的时候，就会用SimpleAsyncTaskExecutor这个线程池。
		- SimpleAsyncTaskExecutor并不是真的线程池，它是不会重用线程的，每次调用都会创建一个新的线程，也没有最大线程数设置。并发大的时候会产生严重的性能问题。
- 什么是Spring的三级缓存#card#Java
	- singletonObjects是一级缓存，存储的是完整创建好的单例bean对象。在创建一个单例bean时，会先从singletonObjects中尝试获取该bean的实例，如果能够获取到，则直接返回该实例，否则继续创建该bean。
	- earlySingletonObjects是二级缓存，存储的是尚未完全创建好的单例bean对象。在创建单例bean时，如果发现该bean存在循环依赖，则会先创建该bean的"半成品"对象，并将"半成品"对象存储到earlySingletonObjects中。当循环依赖的bean创建完成后，Spring会将完整的bean实例对象存储到singletonObjects中，并将earlySingletonObjects中存储的代理对象替换为完整的bean实例对象。这样可以保证单例bean的创建过程不会出现循环依赖问题。
	- singletonFactories是三级缓存，存储的是单例bean的创建工厂。当一个单例bean被创建时，Spring会先将该bean的创建工厂存储到singletonFactories中，然后再执行创建工厂的getObject()方法，生成该bean的实例对象。在该bean被其他bean引用时，Spring会从singletonFactories中获取该bean的创建工厂，创建出该bean的实例对象，并将该bean的实例对象存储到singletonObjects中。
- Spring中@Service 、@Component、@Repository等注解区别是什么？#card#Java
	- @Component：是一个通用的组件声明注解，表示该类是一个Spring组件。它可以用于任何Spring管理的组件。
	- @Service：通常用于标记服务层的组件。虽然它本质上与@Component相同，但这个注解表示该类属于服务层，这有助于区分不同层次的组件。
	  id:: 7382467b-c71a-42b8-ba3e-8bf0cdd85261
	- @Repository：用于标记数据访问层的组件，即DAO（Data Access Object）层。这个注解除了将类标识为Spring组件之外，还能让Spring为它提供一些持久化特定的功能，比如异常转换。
	- @Controller：用于标记控制层的组件，特别是在Spring MVC中用于定义控制器类。这个注解通知Spring该类应当作为控制器处理HTTP请求。
- Spring Bean的生命周期是怎么样的？#card#Java
	- 创建、使用、销毁。
- 如何在Spring启动过程中做缓存预热#card#Java
	- 在应用程序启动时，可以通过监听应用启动事件，或者在应用的初始化阶段，将需要缓存的数据加载到缓存中。
	- 也可以通过CommandLineRunner 和 ApplicationRunner 来实现这个功能。
- InnoDB和MyISAM有什么区别？#card#mysql
	- 一、InnoDB支持事务，MyISAM不支持
	- 二、InnoDB 是聚集索引，MyISAM 是非聚集索引。MyISAM是采用了一种索引和数据分离的存储方式，Innodb的聚簇索引中索引和数据在一起。
	- 三、InnoDB支持外键，MyISAM不支持
	- 四、InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。
	- 五、InnoDB不支持FULLTEXT类型的索引（5.6之前不支持全文索引）
	- 六、InnoDB中不保存表的行数，但是MyISAM只要简单的读出保存好的行数即可
	- 七、对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引
	- 八、清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表
- char和varchar的区别？#card#mysql
	- char是一种定长的数据类型，它的长度固定且在存储时会自动在结尾添加空格来将字符串填满指定的长度。char的长度范围是0-255。
	- varchar是一种可变长度的数据类型，它只会存储实际的字符串内容，不会填充空格。因此，在存储短字符串时，varchar可以节省空间。varchar的长度范围是0-65535（MySQL 5.0.3之后的版本）。
- 什么是数据库范式，为什么要反范式？#card#mysql
	- 第一范式（1NF）是说，数据库表中的属性的原子性的，要求属性具有原子性，不可再被拆分；
		- 比如地址如果都细化拆分成省、市、区、街道、小区等等多个字段这就是符合第一范式的， 如果地址就是一个字段，那就不符合了。
	- 第二范式（2NF）是说，数据库表中的每个实例或记录必须可以被唯一地区分，说白了就是要有主键，其他的字段都依赖于主键。
	- 第三范式（3NF）是说，任何非主属性不依赖于其它非主属性，也就是说，非主键外的所有字段必须互不依赖
- InnoDB支持哪几种行格式#card#mysql
	- COMPACT ：是MySQL 5.0之前的默认格式，除了保存字段值外，还会利用空值列表保存null值，还会记录变长字段长度列表和记录头信息。
	- REDUNDANT ：Redundant 是 MySQL5.0 版本之前 InnoDB 的行记录存储方式，用的比较少，Redundant 行格式会把该条记录中所有列 (包括隐藏列) 的长度信息都存储到 '字段长度偏移列表' 中。
	- DYNAMIC：DYNAMIC格式在MySQL 5.7版本引入，是COMPACT格式的改进版。它保持了COMPACT格式的优点，同时在存储大的可变长度列时更加灵活，能够动态地选择存储在页内或页外。DYNAMIC格式适用于大部分的应用场景，并在存储空间和性能上做了一定的平衡。其结构和COMPACT大致相同；
	- COMPRESSED：是MySQL 5.1中InnoDB的新特性之一，它可以在存储数据时对数据进行压缩，从而减小磁盘占用空间。它的缺点是增加了CPU的使用，可能会降低一些查询的性能。COMPRESSED 行格式是在 DYNAMIC 行格式的基础上添加了页外压缩功能。在存储时，如果发现数据可以通过压缩减小存储空间，就会使用压缩方式来存储数据。在查询时，会自动解压缩数据并返回结果。
	- BARRACUDA：是MySQL 5.7引入的一种新格式，相对于前面的格式，支持更多的高级特性，如动态行格式、行级压缩、空间管理等
- 什么是数据库事务？#card#mysql
  id:: 65e5a617-45a9-4135-8048-33811fb94c15
	- 数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。
	- 事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。
		- ●原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
		- ●一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。
		- ●隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
		- ●持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。
- 什么是脏读、幻读、不可重复读？#card#mysql
	- 脏读：读到了其他事务还没有提交的数据。
	- 不可重复读：对某数据进行读取过程中，有其他事务对数据进行了修改（UPDATE、DELETE)，导致第二次读取的结果不同。
	- 幻读：事务在做范围查询过程中，有另外一个事务对范围内新增了记录(INSERT)，导致范围查询的结果条数不一致。
- MySQL中的事务隔离级别？#card#mysql
	- 未提交读(Read uncommitted)是最低的隔离级别。通过名字我们就可以知道，在这种事务隔离级别下，一个事务可以读到另外一个事务未提交的数据。这种隔离级别下会存在幻读、不可重复读和脏读的问题。
	- 提交读(Read committed)也可以翻译成读已提交，通过名字也可以分析出，在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据。所以，这种隔离级别是可以避免脏读的发生的。
	- 可重复读(Repeatable reads)，由于提交读隔离级别会产生不可重复读的读现象。所以，比提交读更高一个级别的隔离级别就可以解决不可重复读的问题。这种隔离级别就叫可重复读。但是这种隔离级别没办法彻底解决幻读。
	- 可串行化(Serializable)是最高的隔离级别，前面提到的所有的隔离级别都无法解决的幻读，在可串行化的隔离级别中可以解决。
-
-
-
-