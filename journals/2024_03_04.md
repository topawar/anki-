- finally中代码一定会执行吗？#card#Java
	- 通常情况下，finally的代码一定会被执行，但是这是有前提的：
		- 1、对应 try 语句块被执行，
		- 2、程序正常运行。
	- 发生以下情况，都会导致finally不会执行
		- 1、System.exit()方法被执行
		- 2、Runtime.getRuntime().halt()方法被执行
		- 3、try或者catch中有死循环
		- 4、操作系统强制杀掉了JVM进程，如执行了kill -9
		- 5、其他原因导致的虚拟机崩溃了
		- 6、虚拟机所运行的环境挂了，如计算机电源断了
- Java中的枚举有什么特点和好处#card#Java
	- 枚举的valueOf可以自动对入参进行非法参数的校验
	- 可以调用枚举中的方法，相对于普通的常量来说操作性更强
	- 枚举实现接口的话，可以很容易的实现策略模式
	- 枚举可以自带属性，扩展性更强
- 什么是AIO、BIO和NIO#card#Java
	- BIO （Blocking I/O）：同步阻塞I/O，是JDK1.4之前的传统IO模型。 线程发起IO请求后，一直阻塞，直到缓冲区数据就绪后，再进入下一步操作。
	- NIO （Non-Blocking I/O）：同步非阻塞IO，线程发起IO请求后，不需要阻塞，立即返回。用户线程不原地等待IO缓冲区，可以先做一些其他操作，只需要定时轮询检查IO缓冲区数据是否就绪即可。
	- AIO （ Asynchronous I/O）：异步非阻塞I/O模型。线程发起IO请求后，不需要阻塞，立即返回，也不需要定时轮询检查结果，异步IO操作之后会回调通知调用方。
- Java是值传递还是引用传递#card#Java
	- 值传递
- JDK新版本中都有哪些新特性#card#Java
	- JDK 8中推出了Lambda表达式、Stream、Optional、新的日期API等
	- JDK 9中推出了模块化
	- JDK 10中推出了本地变量类型推断
	- JDK 12中增加了switch表达式
	- JDK 13中增加了text block
	- JDK 14中增加了Records
	- JDK 14中增加了instance模式匹配
	- JDK 15中增加了封闭类
	- JDK 17中扩展了switch模式匹配
	- JDK 21中增加了协程
- String是如何实现不可变的#card#Java
	- String类被声明为final，这意味着它不能被继承。那么他里面的方法就是没办法被覆盖的。
	- 用final修饰字符串内容的char[]（从JDK 1.9开始，char[]变成了byte[]），由于该数组被声明为final，一旦数组被初始化，就不能再指向其他数组。
	- String类没有提供用于修改字符串内容的公共方法。例如，没有提供用于追加、删除或修改字符的方法。如果需要对字符串进行修改，会创建一个新的String对象。
- 什么是序列化与反序列化#card#Java
	- 序列化就是把Java对象序列化成字节数组的过程，反序列化就是把字节数组再转换成Java对象的过程。
- 为什么建议自定义一个无参构造函数#card#Java
	- 1.反射及序列化要求
	- 在使用Java反射或者序列化/反序列化时，经常是调用类的无参构造函数进行对象创建的。
	- 2. 兼容性和可扩展性
	- 许多Java框架和库，如Spring、Hibernate、Jackson等，在进行对象的创建和初始化时，依赖于类的无参构造器。如果没有定义无参构造器，这些框架可能无法正常工作。
	- 3. JavaBean规范
	- 根据JavaBean规范，一个标准的JavaBean必须拥有一个公共的无参构造器。这使得JavaBean可以被实例化，并且其属性可以通过反射机制被外部访问和修改。
	- 4. 子类构造器的默认行为
	- 在Java中，子类构造器默认会调用父类的无参构造器。如果父类没有定义无参构造器，而子类又没有显式调用父类的其他构造器，这将导致编译错误。
-
-