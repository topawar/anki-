- 什么是类型擦除？#card#Java
	- 类型擦除是Java在处理泛型的一种方式，在编译后的字节码文件中，会把泛型的信息擦除掉。
- 泛型中K T V E代表什么含义。#card#Java
	- E – Element (在集合中使用，因为集合中存放的是元素)
	- T – Type（Java 类）
	- K – Key（键）
	- V – Value（值）
	- N – Number（数值类型）
	- ？ – 表示不确定的java类型（无限制通配符类型）
- 泛型中上下界限定符extends 和 super有什么区别？#card#Java
	- <? extends T> 表示类型的上界，表示参数化类型的可能是T 或是 T的子类。
	  logseq.order-list-type:: number
	- <? super T> 表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至Object
	  logseq.order-list-type:: number
- 什么是反射机制？为什么反射慢？#card#Java
	- 反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有属性和方法。
	- 反射慢的原因：
		- 1、由于反射涉及动态解析的类型，因此不能执行某些Java虚拟机优化，如JIT优化。
		- 2、在使用反射时，参数需要包装（boxing)成Object[] 类型，但是真正方法执行的时候，又需要再拆包（unboxing)成真正的类型，这些动作不仅消耗时间，而且过程中也会产生很多对象，对象一多就容易导致GC，GC也会导致应用变慢。
		- 3、反射调用方法时会从方法数组中遍历查找，并且会检查可见性。这些动作都是耗时的。
		- 4、不仅方法的可见性要做检查，参数也需要做很多额外的检查。
- 反射的优缺点#card#Java
	- 反射的好处就是可以提升程序的灵活性和扩展性，比较容易在运行期干很多事情。但是他带来的问题更多，主要由以下几个：
	- 1、代码可读性低及可维护性
	- 2、反射代码执行的性能低
	- 3、反射破坏了封装性
- Java中创建对象有哪些种方式#card#Java
	- new
	  logseq.order-list-type:: number
	- 反射
	  logseq.order-list-type:: number
	- clone方法
	  logseq.order-list-type:: number
	- 反序列化
	  logseq.order-list-type:: number
- 什么是元注解，分别有哪些，都具备什么作用？#card#Java
	- 定义其他注解的注解 。
	- 元注解有四个:
		- @Retention:指定被修饰的注解的生命周期，即注解在源代码、编译时还是运行时保留。它有三个可选的枚举值：SOURCE、CLASS和RUNTIME。默认为CLASS。
		- @Target:指定被修饰的注解可以应用于的元素类型，如类、方法、字段等。这样可以限制注解的使用范围，避免错误使用。
		- @Documented:用于指示注解是否会出现在生成的Java文档中。如果一个注解被@Documented元注解修饰，则该注解的信息会出现在API文档中，方便开发者查阅。
		- @Inherited:指示被该注解修饰的注解是否可以被继承。默认情况下，注解不会被继承，即子类不会继承父类的注解。但如果将一个注解用@Inherited修饰，那么它就可以被子类继承。
- 什么是序列化？#card#Java
	- 序列化是将对象转换为可传输格式的过程。 是一种数据的持久化手段。一般广泛应用于网络传输，RMI和RPC等场景中。
- serialVersionUID 有何用途? 如果没定义会有什么问题？#card#Java
	- 如果一个类实现了Serializable接口，但是没有定义serialVersionUID，然后序列化。在序列化之后，由于某些原因，我们对该类做了变更，重新启动应用后，我们相对之前序列化过的对象进行反序列化的话就会报错。
- 说一说个Java异常处理相关的几个关键字，以及简单用法。#card#Java
	- try用来指定一块预防所有异常的程序；
	- catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；
	- finally为确保一段代码不管发生什么异常状况都要被执行；
	- throw语句用来明确地抛出一个异常；
	- throws用来声明一个方法可能抛出的各种异常；